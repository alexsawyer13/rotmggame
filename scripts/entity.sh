ENTITIES_PATH="game/entity.odin"
COMPONENTS_PATH="game/components.odin"

# Get all game files
FILES=$(find "game" -type f -name "*.odin")

COMPONENTS=""
for FILE in $FILES; do
	# For each file, grab all of its components
	FILE_COMPONENTS=$(cat "$FILE" | grep -E -o "[a-zA-Z_]*_Component :: struct" | sed -E "s/([a-zA-Z]*)_Component :: struct/\1/")
	[[ -z $FILE_COMPONENTS ]] || COMPONENTS="$COMPONENTS $FILE_COMPONENTS"
done

write() {
	echo -e $@
}

# Write file to stdout
write "// Generated by entities.sh"
write "// Do NOT edit manually"
write ""
write "package game"
write "" 
write "Entity_Handle :: distinct Handle" 
write "" 
write "Entity :: struct {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\t$name : ${component}_Handle," 
done
write "}" 
write "" 
write "Ecs :: struct {" 
write "\tentities : PackedArray(Entity)," 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\t${name}_components : PackedArray(${component}_Component)," 
done
write "}" 
write "" 
write "make_ecs :: proc(){" 
write "\tg_ecs.entities = make_packed_array(Entity)" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\tg_ecs.${name}_components = make_packed_array(${component}_Component)"
done
write "}" 
write "" 
write "delete_ecs :: proc() {" 
write "\tdelete_packed_array(&g_ecs.entities)" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\tdelete_packed_array(&g_ecs.${name}_components)" 
done
write "}" 
write "" 
write "// ----- Entities -----" 
write "" 
write "make_entity :: proc() -> Entity_Handle {" 
write "\treturn Entity_Handle(insert_packed_array(&g_ecs.entities, Entity {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\t\t${component}_Handle {-1, -1},"
done
write "\t}))" 
write "}" 
write "" 
write "remove_entity :: proc(e : Entity_Handle) {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\ttry_remove_${name}_component(e)"
done
write "\tif !remove_packed_array(&g_ecs.entities, Handle(e)) {" 
write "\t\tpanic(\"Trying to remove entity that doesn't exist\")" 
write "\t}" 
write "}" 
write "" 
write "try_remove_entity :: proc(e : Entity_Handle) {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "\ttry_remove_${name}_component(e)"
done
write "\tremove_packed_array(&g_ecs.entities, Handle(e))" 
write "}" 
write "" 
write "get_entity :: #force_inline proc(e : Entity_Handle) -> ^Entity {" 
write "\treturn get_packed_array(g_ecs.entities, Handle(e))" 
write "}" 
write "" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "// ----- $component component -----" 
	write "" 
	write "${component}_Handle :: distinct Handle" 
	write "" 
	write "add_${name}_component :: proc(e : Entity_Handle, c : ${component}_Component = {}) -> ${component}_Handle {" 
	write "\tent := get_entity(e)" 
	write "\tif ent == nil do return {-1, -1}" 
	write "\t\tent.${name} = ${component}_Handle(insert_packed_array(&g_ecs.${name}_components, c))" 
	write "\treturn ent.${name}"
	#write "\treturn get_packed_array(g_ecs.${name}_components, Handle(ent.${name}))" 
	write "}" 
	write "" 
	write "remove_${name}_component :: proc(e : Entity_Handle) {" 
	write "\tent := get_entity(e)" 
	write "\tif ent == nil do panic(\"Removing component from non existent entity\")" 
	write "\tif !remove_packed_array(&g_ecs.${name}_components, Handle(ent.${name})) {" 
	write "\t\tpanic(\"Removing non existent ${name} component\")" 
	write "\t}" 
	write "}" 
	write "" 
	write "try_remove_${name}_component :: proc(e : Entity_Handle) {" 
	write "\tent := get_entity(e)" 
	write "\tif ent == nil do return" 
	write "\tremove_packed_array(&g_ecs.${name}_components, Handle(ent.${name}))" 
	write "}" 
	write "" 
	write "get_${name}_handle :: #force_inline proc(e : Entity_Handle) -> ${component}_Handle {" 
	write "\tent := get_entity(e)" 
	write "\tif ent == nil do return ${component}_Handle {-1, -1}" 
	write "\treturn ent.${name}" 
	write "}" 
	write "" 
	write "get_${name}_component_ent :: #force_inline proc(e : Entity_Handle) -> ^${component}_Component {" 
	write "\tent := get_entity(e)" 
	write "\tif ent == nil do return nil" 
	write "\treturn get_packed_array(g_ecs.${name}_components, Handle(ent.${name}))" 
	write "}" 
	write "" 
	write "get_${name}_component_comp :: #force_inline proc(h : ${component}_Handle) -> ^${component}_Component {" 
	write "\treturn get_packed_array(g_ecs.${name}_components, Handle(h))" 
	write "}" 
	write "" 
	write "get_${name}_component :: proc {" 
	write "\tget_${name}_component_ent," 
	write "\tget_${name}_component_comp," 
	write "}" 
	write ""
	write "${name}_component_foreach :: proc(f : proc(^${component}_Component)) {"
	write "\tfor &c in g_ecs.${name}_components.items {"
	write "\t\tif c.removed do continue"
	write "\t\tf(&c.item)"
	write "\t}"
	write "}"

done
