ENTITIES_PATH="game/entity.odin"
COMPONENTS_PATH="game/components.odin"

# Get names of components from main.odin
COMPONENTS=$(cat "$COMPONENTS_PATH" | grep -E -o "[a-zA-Z_]*_Component :: struct" | sed -E "s/([a-zA-Z]*)_Component :: struct/\1/")

echo $COMPONENTS

for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
done

write() {
	echo $@ >> $ENTITIES_PATH
}

echo "// Generated by entities.sh" > $ENTITIES_PATH
write "// Do NOT edit manually"
write ""
write "package game"
write "" 
write "Entity_Handle :: distinct Handle" 
write "" 
write "Entity :: struct {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "	$name : ${component}_Handle," 
done
write "}" 
write "" 
write "Ecs :: struct {" 
write "	entities : PackedArray(Entity)," 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "	${name}_components : PackedArray(${component}_Component)," 
done
write "}" 
write "" 
write "make_ecs :: proc(){" 
write "	g_ecs.entities = make_packed_array(Entity)" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "g_ecs.${name}_components = make_packed_array(${component}_Component)"
done
write "}" 
write "" 
write "destroy_ecs :: proc() {" 
write "	delete_packed_array(&g_ecs.entities)" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "	delete_packed_array(&g_ecs.${name}_components)" 
done
write "}" 
write "" 
write "// ----- Entities -----" 
write "" 
write "make_entity :: proc() -> Entity_Handle {" 
write "	return Entity_Handle(insert_packed_array(&g_ecs.entities, Entity {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "	${component}_Handle {-1, -1},"
done
write "	}))" 
write "}" 
write "" 
write "remove_entity :: proc(e : Entity_Handle) {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "	try_remove_${name}_component(e)"
done
write "	if !remove_packed_array(&g_ecs.entities, Handle(e)) {" 
write "		panic(\"Trying to remove entity that doesn't exist\")" 
write "	}" 
write "}" 
write "" 
write "try_remove_entity :: proc(e : Entity_Handle) {" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "	try_remove_${name}_component(e)"
done
write "	remove_packed_array(&g_ecs.entities, Handle(e))" 
write "}" 
write "" 
write "get_entity :: #force_inline proc(e : Entity_Handle) -> ^Entity {" 
write "	return get_packed_array(g_ecs.entities, Handle(e))" 
write "}" 
write "" 
for component in $COMPONENTS; do
	name=$(echo $component | sed -E "s/(.*)/\L\1\E/")
	write "// ----- $component component -----" 
	write "" 
	write "${component}_Handle :: distinct Handle" 
	write "" 
	write "add_${name}_component :: proc(e : Entity_Handle, c : ${component}_Component = {}) -> ${component}_Handle {" 
	write "	ent := get_entity(e)" 
	write "	if ent == nil do return {-1, -1}" 
	write "	ent.${name} = ${component}_Handle(insert_packed_array(&g_ecs.${name}_components, c))" 
	write " return ent.${name}"
	#write "	return get_packed_array(g_ecs.${name}_components, Handle(ent.${name}))" 
	write "}" 
	write "" 
	write "remove_${name}_component :: proc(e : Entity_Handle) {" 
	write "	ent := get_entity(e)" 
	write "	if ent == nil do panic(\"Removing component from non existent entity\")" 
	write "	if !remove_packed_array(&g_ecs.${name}_components, Handle(ent.${name})) {" 
	write "		panic(\"Removing non existent ${name} component\")" 
	write "	}" 
	write "}" 
	write "" 
	write "try_remove_${name}_component :: proc(e : Entity_Handle) {" 
	write "	ent := get_entity(e)" 
	write "	if ent == nil do return" 
	write "	remove_packed_array(&g_ecs.${name}_components, Handle(ent.${name}))" 
	write "}" 
	write "" 
	write "get_${name}_handle :: #force_inline proc(e : Entity_Handle) -> ${component}_Handle {" 
	write "	ent := get_entity(e)" 
	write "	if ent == nil do return ${component}_Handle {-1, -1}" 
	write "	return ent.${name}" 
	write "}" 
	write "" 
	write "get_${name}_component_ent :: #force_inline proc(e : Entity_Handle) -> ^${component}_Component {" 
	write "	ent := get_entity(e)" 
	write "	if ent == nil do return nil" 
	write "	return get_packed_array(g_ecs.${name}_components, Handle(ent.${name}))" 
	write "}" 
	write "" 
	write "get_${name}_component_comp :: #force_inline proc(h : ${component}_Handle) -> ^${component}_Component {" 
	write "	return get_packed_array(g_ecs.${name}_components, Handle(h))" 
	write "}" 
	write "" 
	write "get_${name}_component :: proc {" 
	write "	get_${name}_component_ent," 
	write "	get_${name}_component_comp," 
	write "}" 
	write ""
	write "default_${name}_system :: proc() {"
	write "	for &c in g_ecs.${name}_components.items {"
	write "		if c.removed do continue"
	write "		update_${name}_component(&c.item)"
	write "	}"
	write "}"

done
