package build

import "core:log"
import "core:os"
import "core:fmt"
import "core:strings"
import "core:text/regex"

generate_entity_file :: proc() -> bool {
    ENTITIES_PATH :: "game/gen_entities.odin"

    Component :: struct {
        name : string,
        name_lower : string,
        handle_name : string,
        component_name : string,
        component_name_lower : string,
        array_name : string,
    }

    make_component :: proc(name : string) -> Component {
        c : Component
        c.name = strings.clone(name)
        c.name_lower = strings.to_lower(c.name)
        c.handle_name = strings.concatenate({c.name, "_Handle"})
        c.component_name = strings.concatenate({c.name, "_Component"})
        c.component_name_lower = strings.to_lower(c.component_name)
        c.array_name = strings.concatenate({c.name_lower, "_components"})
        return c
    }
    
    delete_component :: proc(c : ^Component) {
        delete(c.name)
        delete(c.name_lower)
        delete(c.handle_name)
        delete(c.component_name)
        delete(c.component_name_lower)
        delete(c.array_name)
    }

	file : File
	file_init(&file, "game/gen_entity.odin")
	file_set_current(&file)

	fmt.println("----- Generating entity.odin -----")

    os_err : os.Error
    game_dir : os.Handle
    game_files : []os.File_Info

    // Get a list of files in game directory
    game_dir, os_err = os.open("game")
    if os_err != nil {
        fmt.println("Failed to open game directory")
        return false
    }
    defer os.close(game_dir)

    game_files, os_err = os.read_dir(game_dir, -1)
    if os_err != nil {
        fmt.println("Failed to read game directory")
        return false
    }
    defer {
        for file in game_files {
            delete(file.fullpath)
        }
        delete(game_files)
    }

    components := make([dynamic]Component)
    defer {
        for &comp in components {
            delete_component(&comp)
        }
        delete(components)
    }

    // Get components from the files
    for f in game_files {
        fmt.println("Reading file:", f.name)
        bytes, file_success := os.read_entire_file(f.fullpath, context.temp_allocator)
        contents := string(bytes)

        iter, reg_err := regex.create_iterator(contents, "([a-zA-Z_]*)_Component :: struct", {}, context.temp_allocator)
        if reg_err != nil do continue

        for {
            capture, index, ok := regex.match_iterator(&iter)
            if !ok do break

            fmt.println("Found component:", capture.groups[1])
            append(&components, make_component(capture.groups[1]))
        }

        free_all(context.temp_allocator)
    }

    fmt.println("Finished reading files")
    fmt.println("Final components:")
    for comp in components {
        fmt.println("\t", comp.name)
    }

    // Write the entity.odin file using these components
    writeln("// Generated by build/entities.odin")
    writeln("// Do NOT edit manually")
    writeln("")
    writeln("package game")
    writeln("" )
    writeln("Entity_Handle :: distinct Handle" )
    writeln("" )
    writeln("Entity :: struct {" )

    for comp in components {
        writeln("\t", comp.name_lower, " : ", comp.handle_name, ",")
    }

    writeln("}" )
    writeln("" )
    writeln("Ecs :: struct {" )
    writeln("\tentities : PackedArray(Entity)," )
    for comp in components {
        writeln("\t", comp.array_name, " : PackedArray(", comp.component_name, "),")
    }
    writeln("}" )
    writeln("" )
    writeln("make_ecs :: proc(){" )
    writeln("\tg_ecs.entities = make_packed_array(Entity)" )
    for comp in components {
        writeln("\tg_ecs.", comp.array_name, " = make_packed_array(", comp.component_name, ")")
    }
    writeln("}" )
    writeln("" )
    writeln("delete_ecs :: proc() {" )
    writeln("\tdelete_packed_array(&g_ecs.entities)" )
    for comp in components {
        writeln("\tdelete_packed_array(&g_ecs.", comp.array_name, ")")
    }
    writeln("}" )
    writeln("" )
    writeln("// ----- Entities -----" )
    writeln("" )
    writeln("make_entity :: proc() -> Entity_Handle {" )
    writeln("\treturn Entity_Handle(insert_packed_array(&g_ecs.entities, Entity {" )
    for comp in components {
        writeln("\t\t", comp.handle_name, " {-1, -1},")
    }
    writeln("\t}))" )
    writeln("}" )
    writeln("" )
    writeln("remove_entity :: proc(e : Entity_Handle) {" )
    for comp in components {
        writeln("\ttry_remove_", comp.component_name_lower, "(e)")
    }
    writeln("\tif !remove_packed_array(&g_ecs.entities, Handle(e)) {" )
    writeln("\t\tpanic(\"Trying to remove entity that doesn't exist\")" )
    writeln("\t}" )
    writeln("}" )
    writeln("" )
    writeln("try_remove_entity :: proc(e : Entity_Handle) {" )
    for comp in components {
        writeln("\ttry_remove_", comp.component_name_lower, "(e)")
    }
    writeln("\tremove_packed_array(&g_ecs.entities, Handle(e))" )
    writeln("}" )
    writeln("" )
    writeln("get_entity :: #force_inline proc(e : Entity_Handle) -> ^Entity {" )
    writeln("\treturn get_packed_array(g_ecs.entities, Handle(e))" )
    writeln("}" )
    writeln("" )
    for comp in components {
	    writeln("// ----- ", comp.name_lower, " component -----" )
	    writeln("" )
	    writeln(comp.handle_name, " :: distinct Handle" )
	    writeln("" )
	    writeln("add_", comp.component_name_lower, ":: proc(e : Entity_Handle, c : ", comp.component_name, " = {}) -> ", comp.handle_name, " {" )
	    writeln("\tent := get_entity(e)" )
	    writeln("\tif ent == nil do return {-1, -1}" )
	    writeln("\t\tent.", comp.name_lower, " = ", comp.handle_name, "(insert_packed_array(&g_ecs.", comp.array_name, ", c))" )
	    writeln("\treturn ent.", comp.name_lower)
	    writeln("}" )
	    writeln("" )
	    writeln("remove_", comp.component_name_lower, " :: proc(e : Entity_Handle) {" )
	    writeln("\tent := get_entity(e)" )
	    writeln("\tif ent == nil do panic(\"Removing ", comp.name_lower, " component from non existent entity\")" )
	    writeln("\tif !remove_packed_array(&g_ecs.", comp.array_name, ", Handle(ent.", comp.name_lower, ")) {" )
	    writeln("\t\tpanic(\"Removing non existent ", comp.name_lower, " component\")" )
	    writeln("\t}" )
	    writeln("}" )
	    writeln("" )
	    writeln("try_remove_", comp.component_name_lower, " :: proc(e : Entity_Handle) {" )
	    writeln("\tent := get_entity(e)" )
	    writeln("\tif ent == nil do return" )
	    writeln("\tremove_packed_array(&g_ecs.", comp.array_name, ", Handle(ent.", comp.name_lower, "))" )
	    writeln("}" )
	    writeln("" )
	    writeln("get_", comp.name_lower, "_handle :: #force_inline proc(e : Entity_Handle) -> ", comp.handle_name, " {" )
	    writeln("\tent := get_entity(e)" )
	    writeln("\tif ent == nil do return ", comp.handle_name, " {-1, -1}" )
	    writeln("\treturn ent.", comp.name_lower)
	    writeln("}" )
	    writeln("" )
	    writeln("get_", comp.component_name_lower, "_ent :: #force_inline proc(e : Entity_Handle) -> ^", comp.component_name, " {" )
	    writeln("\tent := get_entity(e)" )
	    writeln("\tif ent == nil do return nil" )
	    writeln("\treturn get_packed_array(g_ecs.", comp.name_lower, "_components, Handle(ent.", comp.name_lower, "))" )
	    writeln("}" )
	    writeln("" )
	    writeln("get_", comp.component_name_lower, "_comp :: #force_inline proc(h : ", comp.handle_name, ") -> ^", comp.component_name, " {" )
	    writeln("\treturn get_packed_array(g_ecs.", comp.name_lower, "_components, Handle(h))" )
	    writeln("}" )
	    writeln("" )
	    writeln("get_", comp.component_name_lower, " :: proc {" )
	    writeln("\tget_", comp.component_name_lower, "_ent," )
	    writeln("\tget_", comp.component_name_lower, "_comp," )
	    writeln("}" )
	    writeln("")
	    writeln(comp.name_lower, "_component_foreach :: proc(f : proc(^", comp.component_name, ")) {")
	    writeln("\tfor &c in g_ecs.", comp.name_lower, "_components.items {")
	    writeln("\t\tif c.removed do continue")
	    writeln("\t\tf(&c.item)")
	    writeln("\t}")
	    writeln("}")
    }

	file_finish(&file)

    return true
}
