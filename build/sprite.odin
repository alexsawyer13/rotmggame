package build

import "core:os"
import "core:fmt"
import "core:strings"
import "core:strconv"
import "core:image/png"

generate_sprite_file :: proc() -> bool {

	Sprite :: struct {
		width     : string,
		height    : string,

		name      : string,
		enum_name : string,
		fullpath  : string,
	}

	make_sprite :: proc(file : os.File_Info) -> (Sprite, bool) {
		image, err := png.load_from_file(file.fullpath, allocator = context.temp_allocator)
        if err != nil {
            fmt.println("Failed to read ", file.fullpath)
            return Sprite {}, false
		}

		sprite : Sprite
		buffer : [32]byte
		sprite.width = strings.clone(strconv.itoa(buffer[:], image.width))
		sprite.height = strings.clone(strconv.itoa(buffer[:], image.height))
		sprite.name = strings.clone(strings.trim_suffix(file.name, ".png"))
		sprite.enum_name = strings.concatenate({"Sprite_", sprite.name})
		sprite.fullpath = strings.clone(file.fullpath)

		free_all(context.temp_allocator)

		return sprite, true
	}

	delete_image :: proc(sprite : ^Sprite) {
		delete(sprite.width)
		delete(sprite.height)
		delete(sprite.name)
		delete(sprite.enum_name)
		delete(sprite.fullpath)
	}

	fmt.println("----- Generating game/gen_sprite.odin -----")

	file : File
	os_err : os.Error
	sprite_dir : os.Handle
	files : []os.File_Info

	file_init(&file, "game/gen_sprite.odin")
	file_set_current(&file)

	sprites := make([dynamic]Sprite)
	defer delete(sprites)

	// Get all files in sprite directory
    sprite_dir, os_err = os.open("sprites")
    if os_err != nil {
        fmt.println("Failed to open game directory")
        return false
    }
    defer os.close(sprite_dir)

    files, os_err = os.read_dir(sprite_dir, -1)
    if os_err != nil {
        fmt.println("Failed to read game directory")
        return false
    }
    defer {
        for file in files {
            delete(file.fullpath)
        }
        delete(files)
    }

	// Loop through all files and get info about them
    for f in files {
		spr, success := make_sprite(f)
		if success {
			append(&sprites, spr)
		} else {
			fmt.println("Failed to get info for sprite", f.name)
		}
    }
	defer {
		for &image in sprites {
			delete_image(&image)
		}
	}

	// Generate file!

	writeln("// Generated by sprite.sh")
	writeln("// Do NOT edit manually")
	writeln("")
	writeln("package game")
	writeln("")
	writeln("import rl \"vendor:raylib\"")
	writeln("")
	writeln("Sprite :: struct {")
	writeln("	width : i32,")
	writeln("	height : i32,")
	writeln("	texture : rl.Texture2D,")
	writeln("}")
	writeln("")
	writeln("SpriteType :: enum {")
	for spr in sprites {
		writeln("	", spr.enum_name, ",")

	}
	writeln("}")
	writeln("")
	writeln("Sprite_Component :: struct {")
	writeln("	transform : Transform_Handle,")
	writeln("	sprite : SpriteType,")
	writeln("}")
	writeln("")
	writeln("make_sprites :: proc() -> [SpriteType]Sprite {")
	writeln("	sprites : [SpriteType]Sprite")
	writeln("")
	for spr in sprites {
		writeln("	sprites[.", spr.enum_name, "] = {")
		writeln("		width = ", spr.width, ",")
		writeln("		height = ", spr.height, ",")
		writeln("		texture = rl.LoadTexture(\"sprites/", spr.name, ".png\")")
		writeln("	}")
		writeln("")
	}
	writeln("	return sprites")
	writeln("}")
	writeln("")
	writeln("delete_sprites :: proc(sprites : [SpriteType]Sprite) {")
	for spr in sprites {
		writeln("	rl.UnloadTexture(sprites[.", spr.enum_name, "].texture)")
	}
	writeln("}")
	writeln("")
	writeln("update_sprite_component :: #force_inline proc(s : ^Sprite_Component) {")
	writeln("	t : ^Transform_Component = get_transform_component(s.transform)")
	writeln("	if t == nil do return")
	writeln("	draw_sprite_centre(t.pos, t.size, s.sprite, .LayerWorld, t.rot)")
	writeln("}")

	// Write file to disk

	file_finish(&file)

    return true
}
