// Generated by entities.sh
// Do NOT edit manually

package game

Entity_Handle :: distinct Handle

Entity :: struct {
transform : Transform_Handle,
sprite : Sprite_Handle,
control : Control_Handle,
camera : Camera_Handle,
}

Ecs :: struct {
entities : PackedArray(Entity),
transform_components : PackedArray(Transform_Component),
sprite_components : PackedArray(Sprite_Component),
control_components : PackedArray(Control_Component),
camera_components : PackedArray(Camera_Component),
}

make_ecs :: proc(){
g_ecs.entities = make_packed_array(Entity)
g_ecs.transform_components = make_packed_array(Transform_Component)
g_ecs.sprite_components = make_packed_array(Sprite_Component)
g_ecs.control_components = make_packed_array(Control_Component)
g_ecs.camera_components = make_packed_array(Camera_Component)
}

destroy_ecs :: proc() {
delete_packed_array(&g_ecs.entities)
delete_packed_array(&g_ecs.transform_components)
delete_packed_array(&g_ecs.sprite_components)
delete_packed_array(&g_ecs.control_components)
delete_packed_array(&g_ecs.camera_components)
}

// ----- Entities -----

make_entity :: proc() -> Entity_Handle {
return Entity_Handle(insert_packed_array(&g_ecs.entities, Entity {
Transform_Handle {-1, -1},
Sprite_Handle {-1, -1},
Control_Handle {-1, -1},
Camera_Handle {-1, -1},
}))
}

remove_entity :: proc(e : Entity_Handle) {
try_remove_transform_component(e)
try_remove_sprite_component(e)
try_remove_control_component(e)
try_remove_camera_component(e)
if !remove_packed_array(&g_ecs.entities, Handle(e)) {
panic("Trying to remove entity that doesn't exist")
}
}

try_remove_entity :: proc(e : Entity_Handle) {
try_remove_transform_component(e)
try_remove_sprite_component(e)
try_remove_control_component(e)
try_remove_camera_component(e)
remove_packed_array(&g_ecs.entities, Handle(e))
}

get_entity :: #force_inline proc(e : Entity_Handle) -> ^Entity {
return get_packed_array(g_ecs.entities, Handle(e))
}

// ----- Transform component -----

Transform_Handle :: distinct Handle

add_transform_component :: proc(e : Entity_Handle, c : Transform_Component = {}) -> ^Transform_Component {
ent := get_entity(e)
if ent == nil do return nil
ent.transform = Transform_Handle(insert_packed_array(&g_ecs.transform_components, c))
return get_packed_array(g_ecs.transform_components, Handle(ent.transform))
}

remove_transform_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do panic("Removing component from non existent entity")
if !remove_packed_array(&g_ecs.transform_components, Handle(ent.transform)) {
panic("Removing non existent transform component")
}
}

try_remove_transform_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do return
remove_packed_array(&g_ecs.transform_components, Handle(ent.transform))
}

get_transform_handle :: #force_inline proc(e : Entity_Handle) -> Transform_Handle {
ent := get_entity(e)
if ent == nil do return Transform_Handle {-1, -1}
return ent.transform
}

get_transform_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Transform_Component {
ent := get_entity(e)
if ent == nil do return nil
return get_packed_array(g_ecs.transform_components, Handle(ent.transform))
}

get_transform_component_comp :: #force_inline proc(h : Transform_Handle) -> ^Transform_Component {
return get_packed_array(g_ecs.transform_components, Handle(h))
}

get_transform_component :: proc {
get_transform_component_ent,
get_transform_component_comp,
}

transform_system :: proc() {
for &c in g_ecs.transform_components.items {
if c.removed do continue
update_transform_component(&c.item)
}
}
// ----- Sprite component -----

Sprite_Handle :: distinct Handle

add_sprite_component :: proc(e : Entity_Handle, c : Sprite_Component = {}) -> ^Sprite_Component {
ent := get_entity(e)
if ent == nil do return nil
ent.sprite = Sprite_Handle(insert_packed_array(&g_ecs.sprite_components, c))
return get_packed_array(g_ecs.sprite_components, Handle(ent.sprite))
}

remove_sprite_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do panic("Removing component from non existent entity")
if !remove_packed_array(&g_ecs.sprite_components, Handle(ent.sprite)) {
panic("Removing non existent sprite component")
}
}

try_remove_sprite_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do return
remove_packed_array(&g_ecs.sprite_components, Handle(ent.sprite))
}

get_sprite_handle :: #force_inline proc(e : Entity_Handle) -> Sprite_Handle {
ent := get_entity(e)
if ent == nil do return Sprite_Handle {-1, -1}
return ent.sprite
}

get_sprite_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Sprite_Component {
ent := get_entity(e)
if ent == nil do return nil
return get_packed_array(g_ecs.sprite_components, Handle(ent.sprite))
}

get_sprite_component_comp :: #force_inline proc(h : Sprite_Handle) -> ^Sprite_Component {
return get_packed_array(g_ecs.sprite_components, Handle(h))
}

get_sprite_component :: proc {
get_sprite_component_ent,
get_sprite_component_comp,
}

sprite_system :: proc() {
for &c in g_ecs.sprite_components.items {
if c.removed do continue
update_sprite_component(&c.item)
}
}
// ----- Control component -----

Control_Handle :: distinct Handle

add_control_component :: proc(e : Entity_Handle, c : Control_Component = {}) -> ^Control_Component {
ent := get_entity(e)
if ent == nil do return nil
ent.control = Control_Handle(insert_packed_array(&g_ecs.control_components, c))
return get_packed_array(g_ecs.control_components, Handle(ent.control))
}

remove_control_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do panic("Removing component from non existent entity")
if !remove_packed_array(&g_ecs.control_components, Handle(ent.control)) {
panic("Removing non existent control component")
}
}

try_remove_control_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do return
remove_packed_array(&g_ecs.control_components, Handle(ent.control))
}

get_control_handle :: #force_inline proc(e : Entity_Handle) -> Control_Handle {
ent := get_entity(e)
if ent == nil do return Control_Handle {-1, -1}
return ent.control
}

get_control_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Control_Component {
ent := get_entity(e)
if ent == nil do return nil
return get_packed_array(g_ecs.control_components, Handle(ent.control))
}

get_control_component_comp :: #force_inline proc(h : Control_Handle) -> ^Control_Component {
return get_packed_array(g_ecs.control_components, Handle(h))
}

get_control_component :: proc {
get_control_component_ent,
get_control_component_comp,
}

control_system :: proc() {
for &c in g_ecs.control_components.items {
if c.removed do continue
update_control_component(&c.item)
}
}
// ----- Camera component -----

Camera_Handle :: distinct Handle

add_camera_component :: proc(e : Entity_Handle, c : Camera_Component = {}) -> ^Camera_Component {
ent := get_entity(e)
if ent == nil do return nil
ent.camera = Camera_Handle(insert_packed_array(&g_ecs.camera_components, c))
return get_packed_array(g_ecs.camera_components, Handle(ent.camera))
}

remove_camera_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do panic("Removing component from non existent entity")
if !remove_packed_array(&g_ecs.camera_components, Handle(ent.camera)) {
panic("Removing non existent camera component")
}
}

try_remove_camera_component :: proc(e : Entity_Handle) {
ent := get_entity(e)
if ent == nil do return
remove_packed_array(&g_ecs.camera_components, Handle(ent.camera))
}

get_camera_handle :: #force_inline proc(e : Entity_Handle) -> Camera_Handle {
ent := get_entity(e)
if ent == nil do return Camera_Handle {-1, -1}
return ent.camera
}

get_camera_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Camera_Component {
ent := get_entity(e)
if ent == nil do return nil
return get_packed_array(g_ecs.camera_components, Handle(ent.camera))
}

get_camera_component_comp :: #force_inline proc(h : Camera_Handle) -> ^Camera_Component {
return get_packed_array(g_ecs.camera_components, Handle(h))
}

get_camera_component :: proc {
get_camera_component_ent,
get_camera_component_comp,
}

camera_system :: proc() {
for &c in g_ecs.camera_components.items {
if c.removed do continue
update_camera_component(&c.item)
}
}
