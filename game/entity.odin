// Generated by entities.sh
// Do NOT edit manually

package game

Entity_Handle :: distinct Handle

Entity :: struct {
	rect_collider : Rect_Collider_Handle,
	sprite : Sprite_Handle,
	camera : Camera_Handle,
	projectile : Projectile_Handle,
	bandit_king : Bandit_King_Handle,
	bandit : Bandit_Handle,
	transform : Transform_Handle,
	control : Control_Handle,
	target : Target_Handle,
}

Ecs :: struct {
	entities : PackedArray(Entity),
	rect_collider_components : PackedArray(Rect_Collider_Component),
	sprite_components : PackedArray(Sprite_Component),
	camera_components : PackedArray(Camera_Component),
	projectile_components : PackedArray(Projectile_Component),
	bandit_king_components : PackedArray(Bandit_King_Component),
	bandit_components : PackedArray(Bandit_Component),
	transform_components : PackedArray(Transform_Component),
	control_components : PackedArray(Control_Component),
	target_components : PackedArray(Target_Component),
}

make_ecs :: proc(){
	g_ecs.entities = make_packed_array(Entity)
	g_ecs.rect_collider_components = make_packed_array(Rect_Collider_Component)
	g_ecs.sprite_components = make_packed_array(Sprite_Component)
	g_ecs.camera_components = make_packed_array(Camera_Component)
	g_ecs.projectile_components = make_packed_array(Projectile_Component)
	g_ecs.bandit_king_components = make_packed_array(Bandit_King_Component)
	g_ecs.bandit_components = make_packed_array(Bandit_Component)
	g_ecs.transform_components = make_packed_array(Transform_Component)
	g_ecs.control_components = make_packed_array(Control_Component)
	g_ecs.target_components = make_packed_array(Target_Component)
}

delete_ecs :: proc() {
	delete_packed_array(&g_ecs.entities)
	delete_packed_array(&g_ecs.rect_collider_components)
	delete_packed_array(&g_ecs.sprite_components)
	delete_packed_array(&g_ecs.camera_components)
	delete_packed_array(&g_ecs.projectile_components)
	delete_packed_array(&g_ecs.bandit_king_components)
	delete_packed_array(&g_ecs.bandit_components)
	delete_packed_array(&g_ecs.transform_components)
	delete_packed_array(&g_ecs.control_components)
	delete_packed_array(&g_ecs.target_components)
}

// ----- Entities -----

make_entity :: proc() -> Entity_Handle {
	return Entity_Handle(insert_packed_array(&g_ecs.entities, Entity {
		Rect_Collider_Handle {-1, -1},
		Sprite_Handle {-1, -1},
		Camera_Handle {-1, -1},
		Projectile_Handle {-1, -1},
		Bandit_King_Handle {-1, -1},
		Bandit_Handle {-1, -1},
		Transform_Handle {-1, -1},
		Control_Handle {-1, -1},
		Target_Handle {-1, -1},
	}))
}

remove_entity :: proc(e : Entity_Handle) {
	try_remove_rect_collider_component(e)
	try_remove_sprite_component(e)
	try_remove_camera_component(e)
	try_remove_projectile_component(e)
	try_remove_bandit_king_component(e)
	try_remove_bandit_component(e)
	try_remove_transform_component(e)
	try_remove_control_component(e)
	try_remove_target_component(e)
	if !remove_packed_array(&g_ecs.entities, Handle(e)) {
		panic("Trying to remove entity that doesn't exist")
	}
}

try_remove_entity :: proc(e : Entity_Handle) {
	try_remove_rect_collider_component(e)
	try_remove_sprite_component(e)
	try_remove_camera_component(e)
	try_remove_projectile_component(e)
	try_remove_bandit_king_component(e)
	try_remove_bandit_component(e)
	try_remove_transform_component(e)
	try_remove_control_component(e)
	try_remove_target_component(e)
	remove_packed_array(&g_ecs.entities, Handle(e))
}

get_entity :: #force_inline proc(e : Entity_Handle) -> ^Entity {
	return get_packed_array(g_ecs.entities, Handle(e))
}

// ----- Rect_Collider component -----

Rect_Collider_Handle :: distinct Handle

add_rect_collider_component :: proc(e : Entity_Handle, c : Rect_Collider_Component = {}) -> Rect_Collider_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.rect_collider = Rect_Collider_Handle(insert_packed_array(&g_ecs.rect_collider_components, c))
	return ent.rect_collider
}

remove_rect_collider_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.rect_collider_components, Handle(ent.rect_collider)) {
		panic("Removing non existent rect_collider component")
	}
}

try_remove_rect_collider_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.rect_collider_components, Handle(ent.rect_collider))
}

get_rect_collider_handle :: #force_inline proc(e : Entity_Handle) -> Rect_Collider_Handle {
	ent := get_entity(e)
	if ent == nil do return Rect_Collider_Handle {-1, -1}
	return ent.rect_collider
}

get_rect_collider_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Rect_Collider_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.rect_collider_components, Handle(ent.rect_collider))
}

get_rect_collider_component_comp :: #force_inline proc(h : Rect_Collider_Handle) -> ^Rect_Collider_Component {
	return get_packed_array(g_ecs.rect_collider_components, Handle(h))
}

get_rect_collider_component :: proc {
	get_rect_collider_component_ent,
	get_rect_collider_component_comp,
}

rect_collider_component_foreach :: proc(f : proc(^Rect_Collider_Component)) {
	for &c in g_ecs.rect_collider_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Sprite component -----

Sprite_Handle :: distinct Handle

add_sprite_component :: proc(e : Entity_Handle, c : Sprite_Component = {}) -> Sprite_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.sprite = Sprite_Handle(insert_packed_array(&g_ecs.sprite_components, c))
	return ent.sprite
}

remove_sprite_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.sprite_components, Handle(ent.sprite)) {
		panic("Removing non existent sprite component")
	}
}

try_remove_sprite_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.sprite_components, Handle(ent.sprite))
}

get_sprite_handle :: #force_inline proc(e : Entity_Handle) -> Sprite_Handle {
	ent := get_entity(e)
	if ent == nil do return Sprite_Handle {-1, -1}
	return ent.sprite
}

get_sprite_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Sprite_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.sprite_components, Handle(ent.sprite))
}

get_sprite_component_comp :: #force_inline proc(h : Sprite_Handle) -> ^Sprite_Component {
	return get_packed_array(g_ecs.sprite_components, Handle(h))
}

get_sprite_component :: proc {
	get_sprite_component_ent,
	get_sprite_component_comp,
}

sprite_component_foreach :: proc(f : proc(^Sprite_Component)) {
	for &c in g_ecs.sprite_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Camera component -----

Camera_Handle :: distinct Handle

add_camera_component :: proc(e : Entity_Handle, c : Camera_Component = {}) -> Camera_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.camera = Camera_Handle(insert_packed_array(&g_ecs.camera_components, c))
	return ent.camera
}

remove_camera_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.camera_components, Handle(ent.camera)) {
		panic("Removing non existent camera component")
	}
}

try_remove_camera_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.camera_components, Handle(ent.camera))
}

get_camera_handle :: #force_inline proc(e : Entity_Handle) -> Camera_Handle {
	ent := get_entity(e)
	if ent == nil do return Camera_Handle {-1, -1}
	return ent.camera
}

get_camera_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Camera_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.camera_components, Handle(ent.camera))
}

get_camera_component_comp :: #force_inline proc(h : Camera_Handle) -> ^Camera_Component {
	return get_packed_array(g_ecs.camera_components, Handle(h))
}

get_camera_component :: proc {
	get_camera_component_ent,
	get_camera_component_comp,
}

camera_component_foreach :: proc(f : proc(^Camera_Component)) {
	for &c in g_ecs.camera_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Projectile component -----

Projectile_Handle :: distinct Handle

add_projectile_component :: proc(e : Entity_Handle, c : Projectile_Component = {}) -> Projectile_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.projectile = Projectile_Handle(insert_packed_array(&g_ecs.projectile_components, c))
	return ent.projectile
}

remove_projectile_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.projectile_components, Handle(ent.projectile)) {
		panic("Removing non existent projectile component")
	}
}

try_remove_projectile_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.projectile_components, Handle(ent.projectile))
}

get_projectile_handle :: #force_inline proc(e : Entity_Handle) -> Projectile_Handle {
	ent := get_entity(e)
	if ent == nil do return Projectile_Handle {-1, -1}
	return ent.projectile
}

get_projectile_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Projectile_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.projectile_components, Handle(ent.projectile))
}

get_projectile_component_comp :: #force_inline proc(h : Projectile_Handle) -> ^Projectile_Component {
	return get_packed_array(g_ecs.projectile_components, Handle(h))
}

get_projectile_component :: proc {
	get_projectile_component_ent,
	get_projectile_component_comp,
}

projectile_component_foreach :: proc(f : proc(^Projectile_Component)) {
	for &c in g_ecs.projectile_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Bandit_King component -----

Bandit_King_Handle :: distinct Handle

add_bandit_king_component :: proc(e : Entity_Handle, c : Bandit_King_Component = {}) -> Bandit_King_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.bandit_king = Bandit_King_Handle(insert_packed_array(&g_ecs.bandit_king_components, c))
	return ent.bandit_king
}

remove_bandit_king_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.bandit_king_components, Handle(ent.bandit_king)) {
		panic("Removing non existent bandit_king component")
	}
}

try_remove_bandit_king_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.bandit_king_components, Handle(ent.bandit_king))
}

get_bandit_king_handle :: #force_inline proc(e : Entity_Handle) -> Bandit_King_Handle {
	ent := get_entity(e)
	if ent == nil do return Bandit_King_Handle {-1, -1}
	return ent.bandit_king
}

get_bandit_king_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Bandit_King_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.bandit_king_components, Handle(ent.bandit_king))
}

get_bandit_king_component_comp :: #force_inline proc(h : Bandit_King_Handle) -> ^Bandit_King_Component {
	return get_packed_array(g_ecs.bandit_king_components, Handle(h))
}

get_bandit_king_component :: proc {
	get_bandit_king_component_ent,
	get_bandit_king_component_comp,
}

bandit_king_component_foreach :: proc(f : proc(^Bandit_King_Component)) {
	for &c in g_ecs.bandit_king_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Bandit component -----

Bandit_Handle :: distinct Handle

add_bandit_component :: proc(e : Entity_Handle, c : Bandit_Component = {}) -> Bandit_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.bandit = Bandit_Handle(insert_packed_array(&g_ecs.bandit_components, c))
	return ent.bandit
}

remove_bandit_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.bandit_components, Handle(ent.bandit)) {
		panic("Removing non existent bandit component")
	}
}

try_remove_bandit_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.bandit_components, Handle(ent.bandit))
}

get_bandit_handle :: #force_inline proc(e : Entity_Handle) -> Bandit_Handle {
	ent := get_entity(e)
	if ent == nil do return Bandit_Handle {-1, -1}
	return ent.bandit
}

get_bandit_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Bandit_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.bandit_components, Handle(ent.bandit))
}

get_bandit_component_comp :: #force_inline proc(h : Bandit_Handle) -> ^Bandit_Component {
	return get_packed_array(g_ecs.bandit_components, Handle(h))
}

get_bandit_component :: proc {
	get_bandit_component_ent,
	get_bandit_component_comp,
}

bandit_component_foreach :: proc(f : proc(^Bandit_Component)) {
	for &c in g_ecs.bandit_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Transform component -----

Transform_Handle :: distinct Handle

add_transform_component :: proc(e : Entity_Handle, c : Transform_Component = {}) -> Transform_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.transform = Transform_Handle(insert_packed_array(&g_ecs.transform_components, c))
	return ent.transform
}

remove_transform_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.transform_components, Handle(ent.transform)) {
		panic("Removing non existent transform component")
	}
}

try_remove_transform_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.transform_components, Handle(ent.transform))
}

get_transform_handle :: #force_inline proc(e : Entity_Handle) -> Transform_Handle {
	ent := get_entity(e)
	if ent == nil do return Transform_Handle {-1, -1}
	return ent.transform
}

get_transform_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Transform_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.transform_components, Handle(ent.transform))
}

get_transform_component_comp :: #force_inline proc(h : Transform_Handle) -> ^Transform_Component {
	return get_packed_array(g_ecs.transform_components, Handle(h))
}

get_transform_component :: proc {
	get_transform_component_ent,
	get_transform_component_comp,
}

transform_component_foreach :: proc(f : proc(^Transform_Component)) {
	for &c in g_ecs.transform_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Control component -----

Control_Handle :: distinct Handle

add_control_component :: proc(e : Entity_Handle, c : Control_Component = {}) -> Control_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.control = Control_Handle(insert_packed_array(&g_ecs.control_components, c))
	return ent.control
}

remove_control_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.control_components, Handle(ent.control)) {
		panic("Removing non existent control component")
	}
}

try_remove_control_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.control_components, Handle(ent.control))
}

get_control_handle :: #force_inline proc(e : Entity_Handle) -> Control_Handle {
	ent := get_entity(e)
	if ent == nil do return Control_Handle {-1, -1}
	return ent.control
}

get_control_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Control_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.control_components, Handle(ent.control))
}

get_control_component_comp :: #force_inline proc(h : Control_Handle) -> ^Control_Component {
	return get_packed_array(g_ecs.control_components, Handle(h))
}

get_control_component :: proc {
	get_control_component_ent,
	get_control_component_comp,
}

control_component_foreach :: proc(f : proc(^Control_Component)) {
	for &c in g_ecs.control_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
// ----- Target component -----

Target_Handle :: distinct Handle

add_target_component :: proc(e : Entity_Handle, c : Target_Component = {}) -> Target_Handle {
	ent := get_entity(e)
	if ent == nil do return {-1, -1}
		ent.target = Target_Handle(insert_packed_array(&g_ecs.target_components, c))
	return ent.target
}

remove_target_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do panic("Removing component from non existent entity")
	if !remove_packed_array(&g_ecs.target_components, Handle(ent.target)) {
		panic("Removing non existent target component")
	}
}

try_remove_target_component :: proc(e : Entity_Handle) {
	ent := get_entity(e)
	if ent == nil do return
	remove_packed_array(&g_ecs.target_components, Handle(ent.target))
}

get_target_handle :: #force_inline proc(e : Entity_Handle) -> Target_Handle {
	ent := get_entity(e)
	if ent == nil do return Target_Handle {-1, -1}
	return ent.target
}

get_target_component_ent :: #force_inline proc(e : Entity_Handle) -> ^Target_Component {
	ent := get_entity(e)
	if ent == nil do return nil
	return get_packed_array(g_ecs.target_components, Handle(ent.target))
}

get_target_component_comp :: #force_inline proc(h : Target_Handle) -> ^Target_Component {
	return get_packed_array(g_ecs.target_components, Handle(h))
}

get_target_component :: proc {
	get_target_component_ent,
	get_target_component_comp,
}

target_component_foreach :: proc(f : proc(^Target_Component)) {
	for &c in g_ecs.target_components.items {
		if c.removed do continue
		f(&c.item)
	}
}
